LAYER = 1

Found 4 quarters
Pre-calculated 10 halves
# shapes: 256
# halves: 10
# shapes whose halves aren't stable: 0
# quarters: 4

LAYER = 2

Found 14 quarters
Pre-calculated 97 halves
# shapes: 35281
# halves: 97
# shapes whose halves aren't stable: 45
# quarters: 14

LAYER = 3

Found 46 quarters
Pre-calculated 905 halves
# shapes: 3865768
# halves: 917
# shapes whose halves aren't stable: 11627
# quarters: 47

LAYER = 4

...
# shapes: 349728289
# halves: 8148
# shapes whose halves aren't stable: 2002457
# quarters: 152

LAYER = 5

Found 435 quarters
Pre-calculated 62670 halves
# shapes: 26929624298
# halves: 67669
# shapes whose halves aren't stable: 251172538
# quarters: 476

Ideas
- Create a program to display the first 10 shapes in the shapes list.  DONE

Notes
- The database always includes the null shape as part of the halves.
- The database stores key halves and key shapes.
- The halves are all possible shapes that have one half empty, which includes quarter shapes.
- So that's 0..2 adjacent quarters.
- All 1-layer shapes can be made by swapping halves.
- There are only 9 1-layer key shapes.  All 255 1-layer shapes can be made from these.
  - Note: need to mirror some shapes, which is not a operation in-game.
- The shapes are possible shapes that can't be made from the halves by swapping.
- For example, shapes that require stacking, like S---:SSS-.
- There are 45 2-layer key shapes that can't be made by swapping halves.

Questions
- Are there half shapes that can't be made by swapping?  Of course, the stacked ones.
- Can all 2-layer shapes be made by either swapping or stacking? (Hybrid stacking)
- Yes - there are no 2-layers that require crystal as the last step.
- Note: this was done with CONFIG_LAYER 2.  Need to recheck with LAYER 4 or 5.

Ideas
- Implement a shape solver.
- Need various build methods...
  - For example: swapping, stacking, hybrid, etc.
  - All 1-layer shapes can be made by swapping, so the result of the solver only needs to break down to 1-layer shapes.
- The solver needs to output the list of input shapes (1-layer), and the build instructions (how to assemble them).
- Maybe call it a build engine.  Or MAM brain.  Or shape solver.  Or solution finder.
- Also need a method to follow the build instructions to confirm / verify that the solver works.
- Method
  - Input a shape.
  - Determine how to solve it.
  - Output a solution, which contains a list of 1-layer shapes and build instructions.
  - Follow the build instructions
  - Verify the result matches the input
- Run this for all shapes in the database.
- Output a list of the shapes that are not found.
- Figure out a new algorithm how to build them.
- Update the solver with the new algorithm.
- Repeat
- Example, for 2-layer shapes...
  - The solver can ouput one solution that just unstacks the layers.
  - The verifer restacks and compares.

Questions
- Will there be multiple possible solutions?  Yes
- There might be multiple correct, or only some correct.
- Either the verifier needs to be part of the solver to determine which is correct, or ...
- the solver will output multiple possible solutions, and need a verifier for each one.

Notes
- Will need a notation and data structure for build instructions / solutions.

Claw   P---P---:P-------:crCu--Cu:--------
Snake  P-P-P-P-:------Sy:CgCg--Cg:--Cy----:CwcyCw--
Piggy  P---P-P-:WrCmCmWr:P-----P-:P-cwSw--:WmcrCrWm
Other  CuP-P-P-:--P-CuCu:CuCu--P-:--CuCuP-:cr--P-Cu

??? {P-Cg--P-:crCg--P-:crP-Cucr:crP-Cg--:crCgP-Cu} the Cu's must be swapped in on this shape

Test shape "Books" by RunExcept...
https://discord.com/channels/1000343719314198548/1286691966679126126/1287210914394673162

Drop Book?

Questions
- Are there shapes that are possible in 4-layer mode, that are impossible in 5-layer mode?
- I think the claw shapes can be made in both, even if they have fewer layers.
- Are there less than 4 layer shapes only possible in 5-layer mode?

Notes
- Hybrid stacker/swapper
  - If the top layer has no crystals, unstack it.
  - Repeat until layer with a crystal is found.
  - Cut into quarters (unswap), return each quad for each layer.
  - Or, for each layer, return layer with pins for crystals, and use crystal gen.
- This will fail if there are gaps during the swapping.

Ideas
- Make an SPU to verify the solutions.
- Solver output is the SPU input.
- Solution is a list of shapes and instructions.
- List of shapes [S1, S2, S3, ...]
- Instuctions
  - stack
  - cut left/right
  - swap
  - rotate 1,2,3
  - pin push
  - crystal
  - etc.

From SPU...
 * Instructions
 *        F - flush stack
 *        I - input
 *        O - ouput
 *      <n> - move shape at index <n> to top of stack
 *    L,U,R - rotate 90, 180, 270
 *        C - cut
 *        S - stack
 *        X - trash

Ideas
- Use X for crystal, T for trash, P for pin, etc.

Ideas
- Write a TMAM algorithm

TMAM algorithm 0.1
- Multiple factories: layer stacker MAM, gapless CMAM, <gap magic>, etc.
- Analyze / solve
  - If top layer has no crystals, unstack it and send it to the layer stacker.
  - Else if top layer has crystals and (the remaining shape has) no gaps, send it to the gapless CMAM.
  - Else ... <gap magic>
  - repeat until no layers left.
- Verify / check
  - ...
- Construct / build
  - ... <gap magic>
  - gapless CMAM build
  - layer MAM build
- Done

TMAM Shape Solver 0.2
1> Unstack all stackable layers from the top and send to the layer stacking MAM.
2> If the remaining shape is gapless, send it to the quad swapping CMAM.
3> Else if the remaining shape can be made by swapping two stable half shapes - send the half shapes to two half-shape TMAMs.
4> Else <TBD>

- #1 - Maybe also any remaining pins that can be stacked on top?
- Is it better to combine #2 and #3?  A CMAM could create half-shapes, but all of them?

Layer Stacker MAM
- Layers may have solids and gaps and pins.
- Stacks non-crystal layers on top of each other.

Gapless CMAM
- Quarter stacker method.
- Make each quad (multiple layers), and swap them together.
- Layers may have solids and pins(?) and crystals.
- Assume each layer can have multiple crystal colors, so each crystal must be made one quarter at a time.
- Assumes all layers below are also gapless
- Issue: Are pins okay?  Probably not below a crystal.
- Question: The top layer could have gaps - is this useful?

Issues
- Breaking crystal techniques...
  - Creating gaps under crystals ("drops") requires breaking crystal layers.
  - Crating gaps under shelves supported by crystal requires breaking cystal stacks.

Idea
- Store the operation that made the new shape.
- This would at make at least one way to create the shape.
- Not sure if need to store the input shapes, or just the operation would be enough.
- rotate (not needed), stack (I think this only stacks one layer on top), swap (not needed)
- crystal (maybe assume all crystyals where created in the last step?)
- pin push - probably complicated to figure out input shape.

Idea
- Verify that the fat shape list (non-halves) is correct.  DONE
- Check each fat shape to see if is made from stable halves.
- Cut a fat shape in half (both ways) and reassemble.  Should make a new shape in both ways.
- Or rather, that the two halves are both in the halves list.
- Report the ones that fail.

Idea
- Shape solver
- Use the known list to find solutions.
- First, do a second pass on the known list to make sure the thin and fat shapes are correct.  DONE (well, at least they are self-consistent)
- Re-create the list of all quarter shapes (verify that they are complete by cutting all known shapes)
- Re-create the list of one-layer shapes (for stacking on top).  DONE (there are only 17)
- Find shapes of increasing operational complexity...  (not sure how)
- For example
  - Using just thin shapes, make all shapes that are swapped (this should be the same as the thin list).
  - Then do crystal, then stacking, then pin pushing, ???
- Issue: Are there shapes that need more than one step?  Probably.
  - Other than crystal and pin push...
- Record found shapes in different lists according to the operation used to make them,
- Or, store a structure for each new shape found with operations, and maybe the input shapes.
- Write a file (new file format) with solutions.
- Maybe append the solutions to the existing file, or just write different file.

Idea
- Find shapes that can only be made that require parts to fall doing a pin pushed crystal break.

Notes
- Might have found a bug in collapse.
- How does it handle hanging crystals?
- How does it handle shapes supported by a hanging crystal?
- Okay, looks good so far.
- It finds all suported parts first and keeps them.
- Everything else is falling parts.
- Breaks all crystals in the falling parts.
- Finds connected parts on each layer (bottom up) and stacks them from their current positions.

Notes
- Implemented shape verify to check all the non-half shapes for any that could be made by swapping halves.  Did not find any.

Complete list of single layer shapes that are used by stack()...
----:----:----:P---
----:----:----:-P--
----:----:----:--P-
----:----:----:---P
----:----:----:S---
----:----:----:---S
----:----:----:--S-
----:----:----:-S--
----:----:----:SS--
----:----:----:S--S
----:----:----:--SS
----:----:----:-SS-
----:----:----:SSS-
----:----:----:SS-S
----:----:----:S-SS
----:----:----:-SSS
----:----:----:SSSS

Note that they are on the top layer before being passed to stack().

Idea
- Make a solver for just the thin shapes to begin with.
- Tackle fat shapes later.

Issue
- Need a way to check if a full shape is really composed of two or more thin shapes.

Notes
- Modified searcher to remember how to build each shape and output list of solutions for each of the fat shapes.
- The number of solutions matches the number of fat shapes... 2002457
- They are all Stack and PinPush.
- I guess if Crystal was last, then the shape would be swappable (made from possible halves).
- There are 4967 PinPush shapes.
- I see this one...
P--P:SSS-:----:---- <- PP(cc--:cc--:cSSS:c---)
- That looks like a regular stackable shape.
- It does a crystal break, but doesn't need to to make this shape.
- Could try saving only the first? solution found, rather than the last?
- I think it is recording the first one.
- Or, going to need some scoring system to decide which solution to keep.
- Perfer Stack over Pin Push, maybe?
- It might never find other solutions, maybe?

Idea
- Write solutions file DONE

Issues
- For the solutions table, should the key be the shape value instead of the shape?
- Might be smaller / faster, IDK.

Idea
- Solution viewer
- Input a shape
- Read solutions file, recursively find solutions.

Some 2-layer shape biulds...

C:\Users\garre\Projects\shapez2>bin\search2.exe s2 ss2
Found 14 quarters
Pre-calculated 97 halves
# shapes: 35281
# halves: 97
# shapes whose halves aren't stable: 45
# quarters: 14
-P-P:SSSP <- ST(P-P-:P---, ----:SSS-)
c---:SSS- <- ST(c---:----, ----:SSS-)
-c-P:SSSP <- ST(P-c-:P---, ----:SSS-)
c--S:SSSP <- ST(Sc--:P---, ----:SSS-)
S--P:SSS- <- ST(SP--:----, ----:SSS-)
...

# bin\solve.exe s2 -P-P:SSSP:----:----

Conjecture: A possible shape can be classified by the final operation used to make it.
It is either a swap, stack, or pin push.  (crystal is equivalent to swap).
We think we know how to make make all swap shapes.  But now we are trying to distinguish stack from pin push.

For example, if we can identify the shape as a stack, and part that was stacked, we can undo the stack operation
and now we have a new shape.  If it now a pin push shape, we can find the "snake" (and possible falling parts)
and undo the pin push.  If we can reduce it to a swap shape, then we know how to find the solution.

Ideas
- Don't sort the results.
- Print DONE on exit.
- Reduce size of memory and dump file.  Store pair<shape, build>?
  - write test() method to display various data struct sizes.
- find all builds to one shape, like the claw.
  - help dertermine which build is best to store.

Notes
- Ran the search for 5-layer solutions.
- Took 12? hours, wrote the halves, but only 128 solutions to the dump file.
- And hung.
- The Windows memory was very full and did some swapping during the run.
- Maybe the length is too long?  Need to check what the actual number is and the size of the size field.

Claw: PP(-c-P:ScSc:ccc-:c---)
Claw: PP(c-P-:cScS:c--c:cS--)
Claw: PP(c-P-:cScS:cc-c:c---)
Claw: PP(-P-c:ScSc:c-cc:cSS-)
Claw: PP(c-P-:cScS:cc--:cSSS)
Claw: PP(c-P-:cScS:cc-c:cSS-)
Claw: PP(-P-c:ScSc:c-cc:cS--)
Claw: PP(-P-c:ScSc:c-cc:cSP-)
Claw: PP(-P-c:ScSc:c--c:cS--)
Claw: PP(-P-c:ScSc:c-cc:cSc-)
Claw: PP(-c-P:ScSc:cc--:cSSS)
Claw: PP(c-P-:cScS:cc--:ccSS)
Claw: PP(P-c-:cScS:-ccc:ScP-)
Claw: PP(c-P-:cScS:cc-c:ScS-)
Claw: PP(c-P-:cScS:cc-c:ccS-)
Claw: PP(-P-c:ScSc:c-cc:cSPP)
Claw: PP(P-c-:cScS:-cc-:ScP-)
Claw: PP(-P-c:ScSc:c-cc:cSSP)
Claw: PP(-c-P:ScSc:ccc-:cP--)
Claw: PP(-P-c:ScSc:c-cc:cScP)
Claw: PP(c-P-:cScS:cc-c:ScSP)
Claw: PP(-c-P:ScSc:ccc-:c-P-)
Claw: PP(-c-P:ScSc:-cc-:ScP-)
Claw: PP(c-P-:cScS:cc-c:cP--)
Claw: PP(-c-P:ScSc:ccc-:cPP-)
Claw: PP(c-P-:cScS:cc-c:cSSP)
Claw: PP(c-P-:cScS:cc-c:ccSP)
Claw: PP(-c-P:ScSc:ccc-:PcP-)
Claw: PP(c-P-:cScS:cc--:ScS-)
Claw: PP(-c-P:ScSc:cc--:c---)
Claw: PP(c-P-:cScS:c---:cS--)
Claw: PP(c-P-:cScS:cc--:c---)
Claw: PP(-c-P:ScSc:cc--:cP--)
Claw: PP(c-P-:cScS:cc--:cP--)
Claw: PP(c-P-:cScS:cc--:cSS-)
Claw: PP(c-P-:cScS:cc--:ccS-)
Claw: PP(c-P-:cScS:c---:c---)
Claw: PP(-c-P:ScSc:ccc-:cSSS)
Claw: PP(-c-P:ScSc:ccc-:cS--)
Claw: PP(-c-P:ScSc:ccc-:cScS)
Claw: PP(-c-P:ScSc:ccc-:cSP-)
Claw: PP(-c-P:ScSc:cc--:cS--)
Claw: PP(-c-P:ScSc:ccc-:c-S-)
Claw: PP(-c-P:ScSc:cc--:ScS-)
Claw: PP(c-P-:cScS:cc-c:cS--)
Claw: PP(-c-P:ScSc:ccc-:cPS-)
Claw: PP(-c-P:ScSc:ccc-:ScP-)
Claw: PP(c-P-:cScS:cc--:cS--)
Claw: PP(-c-P:ScSc:ccc-:cSS-)
Claw: PP(c-P-:cScS:cc-c:cSSS)
Claw: PP(-c-P:ScSc:ccc-:ccSS)
Claw: PP(-c-P:ScSc:ccc-:ScS-)
Claw: PP(-c-P:ScSc:ccc-:c-c-)
Claw: PP(-c-P:ScSc:cc--:cSS-)
Claw: PP(-c-P:ScSc:cc--:ccS-)
Claw: PP(-c-P:ScSc:ccc-:cc--)
Claw: PP(-c-P:ScSc:ccc-:cPc-)
Claw: PP(-c-P:ScSc:ccc-:ccP-)
Claw: PP(c-P-:cScS:cc--:cc--)
Claw: PP(-c-P:ScSc:ccc-:cSc-)
Claw: PP(-c-P:ScSc:ccc-:ccS-)
Claw: PP(-c-P:ScSc:ccc-:cccS)
Claw: PP(-c-P:ScSc:ccc-:ccc-)
Claw: PP(-c-P:ScSc:cc--:cScS)
Claw: PP(-c-P:ScSc:cc--:cSc-)
Claw: PP(-c-P:ScSc:-cc-:cc--)
Claw: PP(-c-P:ScSc:-cc-:ccSS)
Claw: PP(-c-P:ScSc:cc--:cccS)
Claw: PP(-c-P:ScSc:-cc-:ccP-)
Claw: PP(c-P-:cScS:c---:cc--)
Claw: PP(-c-P:ScSc:-cc-:ccS-)
Claw: PP(-c-P:ScSc:cc--:ccc-)

72 ways of making the claw

Debug shape: P--P:SSS-:----:----

first build found...
DEBUG: PP(cc--:cc--:cSSS:c---)

Others...
DEBUG: PP(cc--:cc--:cSSS:cS--)
DEBUG: PP(cc--:cc--:cSSS:cc--)
DEBUG: PP(cc--:cc--:cSSS:cP--)
DEBUG: PP(-cc-:ScSS:cc--:c---)
DEBUG: PP(cc--:cc--:cSSS:cSP-)
DEBUG: PP(cc--:cc--:cSSS:cSS-)
DEBUG: PP(cc--:cc--:cSSS:cSc-)

Other ways that use stack...
DEBUG: ST(PP--:----:----:----, SSS-:----:----:----)
DEBUG: ST(PP--:----:----:----, SSS-:----:----:----)
DEBUG: ST(P---:SSS-:----:----, P---:----:----:----)

Ideas
- To reduce memory, need to replace shape hash set with a build has table.  Not use both.
- But the changes may be too invasive.

Notes
- Implmented countBits() which just calls popcount().
- So solids and pins count 1 and crystals count 2.

DEBUG: P--P:SSS-:----:----
DEBUG: ST(PP--:----:----:----|2, SSS-:----:----:----|3)
DEBUG: ST(P---:SSS-:----:----|4, P---:----:----:----|1)
DEBUG: PP(cc--:cSSS:c---:c---|13)
DEBUG: PP(c--c:cSSS:c---:cS--|14)
DEBUG: PP(cc--:cc--:cSSS:c---|15)
DEBUG: PP(cc--:cc--:cSSS:cS--|16)

CLAW: P---P---:P-------:crCu--Cu:--------
CLAW: PP(c-P-:cScS:c---:c---|13)
CLAW: PP(c-P-:cScS:c---:cS--|14)
CLAW: PP(-c-P:ScSc:cc--:c---|15)
CLAW: PP(c-P-:cScS:c--c:cS--|16)
CLAW: PP(-c-P:ScSc:ccc-:c---|17)

Idea
- If there's a tie in the score, then count total number of layers.

Without making key parts...
DEBUG: P--P:SSS-:----:----
DEBUG: ST(PP--:----:----:----|2, S-SS:----:----:----|3)
DEBUG: ST(PP--:----:----:----|2, -SSS:----:----:----|3)
DEBUG: ST(P---:SSS-:----:----|4, ---P:----:----:----|1)
